/*
 * generated by Xtext
 */
grammar DebugInternalXtextGrammarTestLanguage ;

// Rule Grammar
ruleGrammar :
	'grammar' ruleGrammarID (
		'with' ruleGrammarID (
			',' ruleGrammarID
		)*
	)? ruleHiddenClause? ruleAbstractMetamodelDeclaration* ruleAbstractRule+
;

// Rule HiddenClause
ruleHiddenClause :
	'hidden' '(' (
		RULE_ID (
			',' RULE_ID
		)*
	)? ')'
;

// Rule GrammarID
ruleGrammarID :
	RULE_ID (
		'.' RULE_ID
	)*
;

// Rule AbstractRule
ruleAbstractRule :
	ruleParserRule |
	ruleTerminalRule |
	ruleEnumRule
;

// Rule AbstractMetamodelDeclaration
ruleAbstractMetamodelDeclaration :
	ruleGeneratedMetamodel |
	ruleReferencedMetamodel
;

// Rule GeneratedMetamodel
ruleGeneratedMetamodel :
	'generate' RULE_ID RULE_STRING (
		'as' RULE_ID
	)?
;

// Rule ReferencedMetamodel
ruleReferencedMetamodel :
	'import' RULE_STRING (
		'as' RULE_ID
	)?
;

// Rule ParserRule
ruleParserRule :
	(
		'fragment' ruleRuleNameAndParams (
			'*' |
			ruleReturnsClause?
		) |
		ruleRuleNameAndParams ruleReturnsClause?
	) ruleHiddenClause? ':' ruleAlternatives ';'
;

// Rule RuleNameAndParams
ruleRuleNameAndParams :
	RULE_ID (
		'[' (
			ruleParameter (
				',' ruleParameter
			)*
		)? ']'
	)?
;

// Rule ReturnsClause
ruleReturnsClause :
	'returns' ruleTypeRef
;

// Rule Parameter
ruleParameter :
	RULE_ID
;

// Rule TypeRef
ruleTypeRef :
	(
		RULE_ID '::'
	)? RULE_ID
;

// Rule Alternatives
ruleAlternatives :
	ruleConditionalBranch (
		(
			'|' ruleConditionalBranch
		)+
	)?
;

// Rule ConditionalBranch
ruleConditionalBranch :
	ruleUnorderedGroup |
	'[' ruleInverseLiteralValue RULE_ID ']' ruleUnorderedGroup
;

// Rule UnorderedGroup
ruleUnorderedGroup :
	ruleGroup (
		(
			'&' ruleGroup
		)+
	)?
;

// Rule Group
ruleGroup :
	ruleAbstractToken (
		ruleAbstractToken+
	)?
;

// Rule AbstractToken
ruleAbstractToken :
	ruleAbstractTokenWithCardinality |
	ruleAction
;

// Rule AbstractTokenWithCardinality
ruleAbstractTokenWithCardinality :
	(
		ruleAssignment |
		ruleAbstractTerminal
	) ruleCardinalities?
;

// Rule Cardinalities
ruleCardinalities :
	'?' |
	'*' |
	'+'
;

// Rule Action
ruleAction :
	'{' ruleTypeRef (
		'.' RULE_ID (
			'=' |
			'+='
		) 'current'
	)? '}'
;

// Rule AbstractTerminal
ruleAbstractTerminal :
	ruleKeyword |
	ruleRuleCall |
	ruleParenthesizedElement |
	rulePredicatedKeyword |
	rulePredicatedRuleCall |
	rulePredicatedGroup
;

// Rule Keyword
ruleKeyword :
	RULE_STRING
;

// Rule RuleCall
ruleRuleCall :
	ruleRuleID (
		'[' ruleNamedArgument (
			',' ruleNamedArgument
		)* ']'
	)?
;

// Rule LiteralValue
ruleLiteralValue :
	'!' |
	'+'
;

// Rule InverseLiteralValue
ruleInverseLiteralValue :
	ruleLiteralValue
;

// Rule NamedArgument
ruleNamedArgument :
	ruleLiteralValue? RULE_ID |
	RULE_ID '=' RULE_ID
;

// Rule TerminalRuleCall
ruleTerminalRuleCall :
	ruleRuleID
;

// Rule RuleID
ruleRuleID :
	RULE_ID (
		'::' RULE_ID
	)*
;

// Rule PredicatedKeyword
rulePredicatedKeyword :
	rulePredicate RULE_STRING
;

// Rule PredicatedRuleCall
rulePredicatedRuleCall :
	rulePredicate RULE_ID
;

// Rule Assignment
ruleAssignment :
	rulePredicate? RULE_ID (
		'+=' |
		'=' |
		'?='
	) ruleAssignableTerminal
;

// Rule Predicate
rulePredicate :
	'=>' |
	'->'
;

// Rule AssignableTerminal
ruleAssignableTerminal :
	ruleKeyword |
	ruleRuleCall |
	ruleParenthesizedAssignableElement |
	ruleCrossReference
;

// Rule ParenthesizedAssignableElement
ruleParenthesizedAssignableElement :
	'(' ruleAssignableAlternatives ')'
;

// Rule AssignableAlternatives
ruleAssignableAlternatives :
	ruleAssignableTerminal (
		(
			'|' ruleAssignableTerminal
		)+
	)?
;

// Rule CrossReference
ruleCrossReference :
	'[' ruleTypeRef (
		'|' ruleCrossReferenceableTerminal
	)? ']'
;

// Rule CrossReferenceableTerminal
ruleCrossReferenceableTerminal :
	ruleKeyword |
	ruleRuleCall
;

// Rule ParenthesizedElement
ruleParenthesizedElement :
	'(' ruleAlternatives ')'
;

// Rule PredicatedGroup
rulePredicatedGroup :
	rulePredicate '(' ruleAlternatives ')'
;

// Rule TerminalRule
ruleTerminalRule :
	'terminal' (
		'fragment' RULE_ID |
		RULE_ID ruleReturnsClause?
	) ':' ruleTerminalAlternatives ';'
;

// Rule TerminalAlternatives
ruleTerminalAlternatives :
	ruleTerminalGroup (
		(
			'|' ruleTerminalGroup
		)+
	)?
;

// Rule TerminalGroup
ruleTerminalGroup :
	ruleTerminalToken (
		ruleTerminalToken+
	)?
;

// Rule TerminalToken
ruleTerminalToken :
	ruleTerminalTokenElement ruleCardinalities?
;

// Rule TerminalTokenElement
ruleTerminalTokenElement :
	ruleCharacterRange |
	ruleTerminalRuleCall |
	ruleParenthesizedTerminalElement |
	ruleAbstractNegatedToken |
	ruleWildcard |
	ruleEOF
;

// Rule ParenthesizedTerminalElement
ruleParenthesizedTerminalElement :
	'(' ruleTerminalAlternatives ')'
;

// Rule AbstractNegatedToken
ruleAbstractNegatedToken :
	ruleNegatedToken |
	ruleUntilToken
;

// Rule NegatedToken
ruleNegatedToken :
	'!' ruleTerminalTokenElement
;

// Rule UntilToken
ruleUntilToken :
	'->' ruleTerminalTokenElement
;

// Rule Wildcard
ruleWildcard :
	'.'
;

// Rule EOF
ruleEOF :
	'EOF'
;

// Rule CharacterRange
ruleCharacterRange :
	ruleKeyword (
		'..' ruleKeyword
	)?
;

// Rule EnumRule
ruleEnumRule :
	'enum' RULE_ID ruleReturnsClause? ':' ruleEnumLiterals ';'
;

// Rule EnumLiterals
ruleEnumLiterals :
	ruleEnumLiteralDeclaration (
		(
			'|' ruleEnumLiteralDeclaration
		)+
	)?
;

// Rule EnumLiteralDeclaration
ruleEnumLiteralDeclaration :
	RULE_ID (
		'=' ruleKeyword
	)?
;

RULE_ID :
	'^'? (
		'a' .. 'z' |
		'A' .. 'Z' |
		'_'
	) (
		'a' .. 'z' |
		'A' .. 'Z' |
		'_' |
		'0' .. '9'
	)*
;

RULE_INT :
	'0' .. '9'+
;

RULE_STRING :
	'"' (
		'\\' . |
		~ (
			'\\' |
			'"'
		)
	)* '"' |
	'\'' (
		'\\' . |
		~ (
			'\\' |
			'\''
		)
	)* '\''
;

RULE_ML_COMMENT :
	'/*' (
		options { greedy = false ; } : .
	)* '*/' { skip(); }
;

RULE_SL_COMMENT :
	'//' ~ (
		'\n' |
		'\r'
	)* (
		'\r'? '\n'
	)? { skip(); }
;

RULE_WS :
	(
		' ' |
		'\t' |
		'\r' |
		'\n'
	)+ { skip(); }
;

RULE_ANY_OTHER :
	.
;