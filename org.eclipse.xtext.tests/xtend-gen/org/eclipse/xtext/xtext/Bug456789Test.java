/**
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.xtext.xtext;

import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.Diagnostician;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.XtextStandaloneSetup;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.tests.AbstractXtextTests;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.junit.Assert;
import org.junit.Test;

/**
 * @author Sebastian Zarnekow - Initial contribution and API
 */
@SuppressWarnings("all")
public class Bug456789Test extends AbstractXtextTests {
  @Override
  public void setUp() throws Exception {
    super.setUp();
    this.with(XtextStandaloneSetup.class);
  }
  
  @Test(timeout = 5000)
  public void doesNotHang_01() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("grammar com.acme.G with org.eclipse.xtext.common.Terminals");
      _builder.newLine();
      _builder.newLine();
      _builder.append("generate g \"bug456789\"");
      _builder.newLine();
      _builder.newLine();
      _builder.append("CompoundStatement: Declaration;");
      _builder.newLine();
      _builder.append("suite: simpleStatement | NL INDENT stmt+ DEDENT;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("test: or_test (\'if\' or_test \'else\' test)? | lambdef;");
      _builder.newLine();
      _builder.append("or_test: and_test (\'or\' and_test)*;");
      _builder.newLine();
      _builder.append("and_test: not_test (\'and\' not_test)*;");
      _builder.newLine();
      _builder.append("not_test: \'not\' not_test | comparison;");
      _builder.newLine();
      _builder.append("comparison: expr (comp_op expr)*;");
      _builder.newLine();
      _builder.append("comp_op: \'<\'|\'>\'|\'==\'|\'>=\'|\'<=\'|\'<>\'|\'!=\'|\'in\'|\'not\' \'in\'|\'is\'|\'is\' \'not\';");
      _builder.newLine();
      _builder.append("expr: xorExpression (\'|\' xorExpression)*;");
      _builder.newLine();
      _builder.append("xorExpression: andExpression (\'^\' andExpression)*;");
      _builder.newLine();
      _builder.append("andExpression: shiftExpression (\'&\' shiftExpression)*;");
      _builder.newLine();
      _builder.append("shiftExpression: arithExpression ((\'<<\'|\'>>\') arithExpression)*;");
      _builder.newLine();
      _builder.append("arithExpression: term ((\'+\'|\'-\') term)*;");
      _builder.newLine();
      _builder.append("term: factor ((\'*\'|\'/\'|\'%\'|\'//\') factor)*;");
      _builder.newLine();
      _builder.append("factor: (\'+\'|\'-\'|\'~\') factor | power;");
      _builder.newLine();
      _builder.append("power: atom trailer* (\'**\' factor)?;");
      _builder.newLine();
      _builder.append("atom: (\'(\' (yieldExpression|testlist_comp)? \')\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'(\' (listmaker)? \')?\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'{\' (dictorsetmaker)? \'}\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'`\' testlist1 \'`\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("ID | NUMBER | STRING+);");
      _builder.newLine();
      _builder.append("listmaker: test ( list_for | (\',\' test)* (\',\')? );");
      _builder.newLine();
      _builder.append("testlist_comp: test ( comp_for | (\',\' test)* (\',\')? );");
      _builder.newLine();
      _builder.append("lambdef: \'lambda\' (varargslist)? \':\' test;");
      _builder.newLine();
      _builder.append("trailer: \'(\' (arglist)? \')\' | \'(\' subscriptlist \')?\' | \'.\' ID;");
      _builder.newLine();
      _builder.append("subscriptlist: subscript (\',\' subscript)* (\',\')?;");
      _builder.newLine();
      _builder.append("subscript: \'.\' \'.\' \'.\' | test | (test)? \':\' (test)? (sliceop)?;");
      _builder.newLine();
      _builder.append("sliceop: \':\' (test)?;");
      _builder.newLine();
      _builder.append("exprlist: expr (\',\' expr)* (\',\')?;");
      _builder.newLine();
      _builder.append("testlist: test (\',\' test)* (\',\')?;");
      _builder.newLine();
      _builder.append("dictorsetmaker: ( (test \':\' test (comp_for | (\',\' test \':\' test)* (\',\')?)) |");
      _builder.newLine();
      _builder.append("                  ");
      _builder.append("(test (comp_for | (\',\' test)* (\',\')?)) );");
      _builder.newLine();
      final XtextResource resource = this.getResourceFromStringAndExpect(_builder.toString(), AbstractXtextTests.UNKNOWN_EXPECTATION);
      EList<EObject> _contents = resource.getContents();
      EObject _get = _contents.get(0);
      final Diagnostic diag = Diagnostician.INSTANCE.validate(_get);
      Assert.assertNotNull("diag", diag);
      int _severity = diag.getSeverity();
      Assert.assertEquals("diag.isError", _severity, Diagnostic.ERROR);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test(timeout = 5000)
  public void doesNotHang_02() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("grammar com.acme.G with org.eclipse.xtext.common.Terminals");
      _builder.newLine();
      _builder.newLine();
      _builder.append("generate g \"bug456789\"");
      _builder.newLine();
      _builder.newLine();
      _builder.append("File: (NL | statements+=Statement)*;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Declaration: ClassDeclaration | FunctionDeclaration;");
      _builder.newLine();
      _builder.append("FunctionDeclaration: \'def\' name=ID parameters=Parameters \':\' body=Suite;");
      _builder.newLine();
      _builder.append("Parameters: \'(\' list=Varargslist? \')\';");
      _builder.newLine();
      _builder.append("Varargslist:");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("(params+=ParameterWithDefault (\',\' params+=ParameterWithDefault)*");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("(\',\' (params+=ExcessPositionalParameterDef (\',\' params+=ExcessKeywordParameterDef)? | params+=ExcessKeywordParameterDef)?)?)?");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("| params+=ExcessPositionalParameterDef (\',\' params+=ExcessKeywordParameterDef)? ");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("| params+=ExcessKeywordParameterDef;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("ParameterWithDefault returns ParameterDef:");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ParameterDef ({ParameterWithDefault.param=current} \'=\' default=Test)");
      _builder.newLine();
      _builder.append(";");
      _builder.newLine();
      _builder.append("ParameterDef: SimpleParameterDef | TupleParameterDef;");
      _builder.newLine();
      _builder.append("ExcessPositionalParameterDef returns ParameterDef: {ExcessPositionalParameterDef} \'*\' name=ID;");
      _builder.newLine();
      _builder.append("ExcessKeywordParameterDef returns ParameterDef: {ExcessKeywordParameterDef} \'**\' name=ID;");
      _builder.newLine();
      _builder.append("SimpleParameterDef: name=ID;");
      _builder.newLine();
      _builder.append("TupleParameterDef: params+=ParameterDef (\',\' params+=ParameterDef)* (\',\')?;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Statement: SimpleStatement | CompoundStatement;");
      _builder.newLine();
      _builder.append("SimpleStatement: SmallStatement ({SmallStatementList.statements+=current} \';\' statements+=SmallStatement)* \';\'? NL;");
      _builder.newLine();
      _builder.append("SmallStatement: ");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ExprStatement | PrintStatement  | DelStatement | PassStatement | FlowStatement |");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("ExecStatement | AssertStatement;");
      _builder.newLine();
      _builder.append("ExprStatement: Testlist ");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("(assignment=AugAssign value=Assignable | (\'=\' value=Assignable)*);");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Assignable returns Expression: YieldExpression | Testlist;");
      _builder.newLine();
      _builder.append("AugAssign: \'+=\' | \'-=\' | \'*=\' | \'/=\' | \'%=\' | \'&=\' | \'|=\' | \'^=\' |");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("\'<<=\' | \'>>=\' | \'**=\' | \'//=\';");
      _builder.newLine();
      _builder.append("PrintStatement: \'print\'|\'>>\' ( values+=Test (\',\' values+=Test)* (\',\')? )?;");
      _builder.newLine();
      _builder.append("DelStatement: \'del\' expression=Expressionlist;");
      _builder.newLine();
      _builder.append("PassStatement: {PassStatement} \'pass\';");
      _builder.newLine();
      _builder.append("FlowStatement: BreakStatement | ContinueStatement | ReturnStatement | RaiseStatement | YieldStatement;");
      _builder.newLine();
      _builder.append("BreakStatement: {BreakStatement} \'break\';");
      _builder.newLine();
      _builder.append("ContinueStatement: {ContinueStatement} \'continue\';");
      _builder.newLine();
      _builder.append("ReturnStatement: {ReturnStatement} \'return\' value=Testlist?;");
      _builder.newLine();
      _builder.append("YieldStatement: {YieldStatement} value=YieldExpression;");
      _builder.newLine();
      _builder.append("RaiseStatement: {RaiseStatement} \'raise\' (firstValue=Test (\',\' secondValue=Test (\',\' thirdValue=Test)?)?)?;");
      _builder.newLine();
      _builder.append("FQN: ID (\'.\' ID)*;");
      _builder.newLine();
      _builder.append("ExecStatement: \'exec\' expression=Expression (\'in\' tests+=Test (\',\' tests+=Test)?)?;");
      _builder.newLine();
      _builder.append("AssertStatement: \'assert\' tests+=Test (\',\' tests+=Test)?;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("CompoundStatement: IfStatement | WhileStatement | ForStatement | TryStatement | WithStatement | Declaration;");
      _builder.newLine();
      _builder.append("IfStatement: \'if\' conditions=Test \':\' thens=Suite (\'elif\' conditions=Test \':\' thens=Suite)* (\'else\' \':\' else=Suite)?;");
      _builder.newLine();
      _builder.append("WhileStatement: \'while\' conditions=Test \':\' body=Suite (\'else\' \':\' else=Suite)?;");
      _builder.newLine();
      _builder.append("ForStatement: \'for\' expressionList=Exprlist \'in\' in=Testlist \':\' body=Suite (\'else\' \':\' else=Suite)?;");
      _builder.newLine();
      _builder.append("TryStatement: (\'try\' \':\' try=Suite");
      _builder.newLine();
      _builder.append("           ");
      _builder.append("((except_clause \':\' Suite)+");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("(\'else\' \':\' else=Suite)?");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("(\'finally\' \':\' finally=Suite)? |");
      _builder.newLine();
      _builder.append("           ");
      _builder.append("\'finally\' \':\' finally=Suite));");
      _builder.newLine();
      _builder.append("withStatement: \'with\' with_item (\',\' with_item)*  \':\' suite;");
      _builder.newLine();
      _builder.append("with_item: test (\'as\' expr)?;");
      _builder.newLine();
      _builder.append("except_clause: \'except\' (test ((\'as\' | \',\') test)?)?;");
      _builder.newLine();
      _builder.append("suite: simpleStatement | NL INDENT stmt+ DEDENT;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("testlist_safe: old_test ((\',\' old_test)+ (\',\')?)?;");
      _builder.newLine();
      _builder.append("old_test: or_test | old_lambdef;");
      _builder.newLine();
      _builder.append("old_lambdef: \'lambda\' (varargslist)? \':\' old_test;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("test: or_test (\'if\' or_test \'else\' test)? | lambdef;");
      _builder.newLine();
      _builder.append("or_test: and_test (\'or\' and_test)*;");
      _builder.newLine();
      _builder.append("and_test: not_test (\'and\' not_test)*;");
      _builder.newLine();
      _builder.append("not_test: \'not\' not_test | comparison;");
      _builder.newLine();
      _builder.append("comparison: expr (comp_op expr)*;");
      _builder.newLine();
      _builder.append("comp_op: \'<\'|\'>\'|\'==\'|\'>=\'|\'<=\'|\'<>\'|\'!=\'|\'in\'|\'not\' \'in\'|\'is\'|\'is\' \'not\';");
      _builder.newLine();
      _builder.append("expr: xorExpression (\'|\' xorExpression)*;");
      _builder.newLine();
      _builder.append("xorExpression: andExpression (\'^\' andExpression)*;");
      _builder.newLine();
      _builder.append("andExpression: shiftExpression (\'&\' shiftExpression)*;");
      _builder.newLine();
      _builder.append("shiftExpression: arithExpression ((\'<<\'|\'>>\') arithExpression)*;");
      _builder.newLine();
      _builder.append("arithExpression: term ((\'+\'|\'-\') term)*;");
      _builder.newLine();
      _builder.append("term: factor ((\'*\'|\'/\'|\'%\'|\'//\') factor)*;");
      _builder.newLine();
      _builder.append("factor: (\'+\'|\'-\'|\'~\') factor | power;");
      _builder.newLine();
      _builder.append("power: atom trailer* (\'**\' factor)?;");
      _builder.newLine();
      _builder.append("atom: (\'(\' (yieldExpression|testlist_comp)? \')\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'(\' (listmaker)? \')?\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'{\' (dictorsetmaker)? \'}\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("\'`\' testlist1 \'`\' |");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("ID | NUMBER | STRING+);");
      _builder.newLine();
      _builder.append("listmaker: test ( list_for | (\',\' test)* (\',\')? );");
      _builder.newLine();
      _builder.append("testlist_comp: test ( comp_for | (\',\' test)* (\',\')? );");
      _builder.newLine();
      _builder.append("lambdef: \'lambda\' (varargslist)? \':\' test;");
      _builder.newLine();
      _builder.append("trailer: \'(\' (arglist)? \')\' | \'(\' subscriptlist \')?\' | \'.\' ID;");
      _builder.newLine();
      _builder.append("subscriptlist: subscript (\',\' subscript)* (\',\')?;");
      _builder.newLine();
      _builder.append("subscript: \'.\' \'.\' \'.\' | test | (test)? \':\' (test)? (sliceop)?;");
      _builder.newLine();
      _builder.append("sliceop: \':\' (test)?;");
      _builder.newLine();
      _builder.append("exprlist: expr (\',\' expr)* (\',\')?;");
      _builder.newLine();
      _builder.append("testlist: test (\',\' test)* (\',\')?;");
      _builder.newLine();
      _builder.append("dictorsetmaker: ( (test \':\' test (comp_for | (\',\' test \':\' test)* (\',\')?)) |");
      _builder.newLine();
      _builder.append("                  ");
      _builder.append("(test (comp_for | (\',\' test)* (\',\')?)) );");
      _builder.newLine();
      _builder.newLine();
      _builder.append("ClassDeclaration: \'class\' ID=ID (\'(\' (testlist)? \')\')? \':\' suite;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("arglist: (argument \',\')* (argument (\',\')?");
      _builder.newLine();
      _builder.append("                         ");
      _builder.append("|\'*\' test (\',\' argument)* (\',\' \'**\' test)? ");
      _builder.newLine();
      _builder.append("                         ");
      _builder.append("|\'**\' test);");
      _builder.newLine();
      _builder.append("argument: test (comp_for)? | test \'=\' test;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("list_iter: list_for | list_if;");
      _builder.newLine();
      _builder.append("list_for: \'for\' exprlist \'in\' testlist_safe (list_iter)?;");
      _builder.newLine();
      _builder.append("list_if: \'if\' old_test (list_iter)?;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("comp_iter: comp_for | comp_if;");
      _builder.newLine();
      _builder.append("comp_for: \'for\' exprlist \'in\' or_test (comp_iter)?;");
      _builder.newLine();
      _builder.append("comp_if: \'if\' old_test (comp_iter)?;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("testlist1: test (\',\' test)*;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("encoding_decl: ID;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("yieldExpression: \'yield\' (testlist)?;");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("INDENT: \'synthetic:INDENT\';");
      _builder.newLine();
      _builder.append("DEDENT: \'synthetic:DEDENT\';");
      _builder.newLine();
      _builder.newLine();
      _builder.append("terminal SL_COMMENT: \'#\' !(\'\\n\'|\'\\r\'|EOF)*;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("terminal NL: \'\\r\'? \'\\n\'|\'\\r\';");
      _builder.newLine();
      _builder.newLine();
      _builder.append("/*");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("* tabs make 8 spaces");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("* indentation is computed from all spaces (tabs are converted first)");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("* ");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("*/");
      _builder.newLine();
      final XtextResource resource = this.getResourceFromStringAndExpect(_builder.toString(), AbstractXtextTests.UNKNOWN_EXPECTATION);
      EList<EObject> _contents = resource.getContents();
      EObject _get = _contents.get(0);
      final Diagnostic diag = Diagnostician.INSTANCE.validate(_get);
      Assert.assertNotNull("diag", diag);
      int _severity = diag.getSeverity();
      Assert.assertEquals("diag.isError", _severity, Diagnostic.ERROR);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
