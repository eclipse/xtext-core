/*******************************************************************************
 * Copyright (c) 2008, 2016 itemis AG and others.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *******************************************************************************/
grammar org.eclipse.xtext.testlanguages.xtextgrammar.XtextGrammarTestLanguage with org.eclipse.xtext.common.Terminals

generate xtextGrammarTest "http://www.eclipse.org/2008/testlanguages/xtextgrammar"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Grammar:
    'grammar' name=GrammarID ('with' usedGrammars+=[Grammar|GrammarID] (',' usedGrammars+=[Grammar|GrammarID])*)?
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule] (',' hiddenTokens+=[AbstractRule])*)? ')')?
	metamodelDeclarations+=AbstractMetamodelDeclaration* 
    (rules+=AbstractRule)+
;

GrammarID returns ecore::EString:
  ID ('.' ID)*;
  
AbstractRule : ParserRule | TerminalRule | EnumRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;
	
// constraint: typeSelect(GeneratedMetamodel).size() == typeSelect(GeneratedMetamodel).alias.size()
// generated metamodels have to have different aliases
GeneratedMetamodel :
	'generate' name=ID ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

// referenced metamodels may share aliases with other referenced metamodels
// and with generated metamodels
ReferencedMetamodel :
	'import' ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

ParserRule :
    name=ID ('returns' type=TypeRef)? (definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule] (',' hiddenTokens+=[AbstractRule])*)? ')')?':' 
    	alternatives=Alternatives   
    ';'
;

TypeRef :
	(metamodel=[AbstractMetamodelDeclaration] '::')? classifier=[ecore::EClassifier]
;

Alternatives returns AbstractElement:
    Group ({Alternatives.groups+=current} ('|' groups+=Group)+)?
;

Group returns AbstractElement:
    AbstractToken ({Group.tokens+=current} (tokens+=AbstractToken)+)?
;

AbstractToken returns AbstractElement:
	AbstractTokenWithCardinality |
	Action
;

/* SuppressWarnings[potentialOverride] */
AbstractTokenWithCardinality returns AbstractElement:
	(Assignment | 
	 AbstractTerminal) (cardinality=('?'|'*'|'+'))?
;

Action returns Action:
	'{' type=TypeRef ('.' feature=ID operator=('='|'+=') 'current')? '}'
;

AbstractTerminal returns AbstractElement: 
   Keyword | RuleCall | ParenthesizedElement
;

Keyword : 
   value=STRING 
;

RuleCall :
   rule=[AbstractRule]
;

Assignment returns Assignment:
   feature=ID operator=('+='|'='|'?=') ^terminal=AssignableTerminal
;

AssignableTerminal returns AbstractElement:
   Keyword | RuleCall | ParenthesizedAssignableElement | CrossReference
;

ParenthesizedAssignableElement returns AbstractElement:
   '(' AssignableAlternatives ')'
;

AssignableAlternatives returns AbstractElement:
    AssignableTerminal ({Alternatives.groups+=current} ('|' groups+=AssignableTerminal)+)?
;

CrossReference :
	'[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']'
;

CrossReferenceableTerminal returns AbstractElement:
   Keyword | RuleCall | ParenthesizedCrossReferenceableElement
;

ParenthesizedCrossReferenceableElement returns AbstractElement:
   '(' CrossReferenceableAlternatives ')'
;

CrossReferenceableAlternatives returns AbstractElement:
    CrossReferenceableTerminal ({Alternatives.groups+=current} ('|' groups+=CrossReferenceableTerminal)+)?
;

ParenthesizedElement returns AbstractElement:
   '(' Alternatives ')'
;

TerminalRule :
	'terminal' name=ID ('returns' type=TypeRef)? ':'
		alternatives=TerminalAlternatives
	';'
;

TerminalAlternatives returns AbstractElement:
	TerminalGroup ({Alternatives.groups+=current} ('|' groups+=TerminalGroup)+)?
;

TerminalGroup returns AbstractElement:
	TerminalToken ({Group.tokens+=current} (tokens+=TerminalToken)+)?
;

/* SuppressWarnings[potentialOverride] */
TerminalToken returns AbstractElement:
	TerminalTokenElement (cardinality=('?'|'*'|'+'))?
;

TerminalTokenElement returns AbstractElement: 
   CharacterRange | RuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard
;

ParenthesizedTerminalElement returns AbstractElement:
   '(' TerminalAlternatives ')'
;

AbstractNegatedToken:
   NegatedToken | UntilToken
;

NegatedToken:
	'!' ^terminal=TerminalTokenElement
;

UntilToken:
	'->' ^terminal=TerminalTokenElement
;

Wildcard:
	{Wildcard} '.'
;

CharacterRange returns AbstractElement:
	Keyword ( {CharacterRange.left=current} '..' right=Keyword)?
;

EnumRule:
    'enum' name=ID ('returns' type=TypeRef)? ':' 
    	alternatives=EnumLiterals   
    ';'
;

EnumLiterals returns AbstractElement:
	EnumLiteralDeclaration ({Alternatives.groups+=current} ('|' groups+=EnumLiteralDeclaration)+)?
; 

EnumLiteralDeclaration:
    enumLiteral=[ecore::EEnumLiteral] ('=' literal=Keyword)?
;
